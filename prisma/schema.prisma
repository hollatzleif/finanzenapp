generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  username  String   @unique
  apiKey    String?  @unique
  createdAt DateTime @default(now())
  
  // Lernen
  level     Int      @default(1)
  progress  Int      @default(0)
  lCoins    Decimal  @default(0) @db.Decimal(10, 2)

  sessions          Session[]
  expenseDefinitions ExpenseDefinition[]
  expenseInstances   ExpenseInstance[]
  resolutions       Resolution[]
  timer             Timer?
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  expiresAt DateTime
  revokedAt DateTime?

  @@index([userId])
}

enum IntervalType {
  EINMALIG
  TAGE
  WOCHEN
  MONATE
  JAHRE
}

enum RatingStatus {
  UNBEWERTET
  BEWERTET
  LEBENSNOTWENDIG
}

enum PlannedType {
  DURCHDACHT
  AFFEKTIV
}

model ExpenseDefinition {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  purpose         String
  amount          Decimal  @db.Decimal(10, 2)
  isRecurring     Boolean  @default(false)
  intervalType    IntervalType
  intervalEvery   Int      @default(1)
  startDate       DateTime
  anchorDayOfMonth Int?
  createdAt       DateTime @default(now())
  timesCharged    Int      @default(0)
  totalPaid       Decimal  @default(0) @db.Decimal(10, 2)
  lastChargedAt   DateTime?

  instances ExpenseInstance[]

  @@index([userId])
}

model ExpenseInstance {
  id                   String        @id @default(uuid())
  userId               String
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  definitionId         String
  definition           ExpenseDefinition @relation(fields: [definitionId], references: [id], onDelete: Cascade)
  purposeSnapshot      String
  amountSnapshot       Decimal       @db.Decimal(10, 2)
  chargedAt            DateTime
  monthKey             String
  isRecurringSnapshot  Boolean
  intervalSnapshot     String
  ratingStatus         RatingStatus  @default(UNBEWERTET)
  ratingValue          Decimal?      @db.Decimal(4, 2)
  q1Happy              Int?
  q2Value              Int?
  q3RepeatNow          Boolean?
  q4NeedElsewhere      Boolean?
  q5Planned            PlannedType?
  ratedAt              DateTime?
  createdAt            DateTime      @default(now())

  @@index([userId, monthKey, ratingStatus])
  @@index([definitionId, chargedAt])
  @@unique([definitionId, chargedAt])
}

enum ResolutionType {
  UNDER_AMOUNT_FOR_RATING
  TARGET_AVG_RATING
  LESS_THAN_LAST_MONTH
  NO_AFFECTIVE_ABOVE_AMOUNT
  MAX_AFFECTIVE_PER_PERIOD
}

enum ResolutionUnit {
  EURO
  PERCENT
}

enum ResolutionPeriod {
  WEEK
  MONTH
}

model Resolution {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        ResolutionType
  monthKey    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Unter X €/% für Ausgaben unter Y Bewertung
  amountThreshold     Decimal?  @db.Decimal(10, 2)
  ratingThreshold      Decimal?  @db.Decimal(4, 2)
  unit                 ResolutionUnit?
  
  // Angestrebte Durchschnittsbewertung
  targetAvgRating      Decimal?  @db.Decimal(4, 2)
  
  // X €/% weniger als letzten Monat
  reductionAmount      Decimal?  @db.Decimal(10, 2)
  reductionUnit        ResolutionUnit?
  
  // Keine affektive Ausgabe über X €
  maxAffectiveAmount   Decimal?  @db.Decimal(10, 2)
  
  // Maximal X affektive Ausgaben pro Woche/Monat
  maxAffectiveCount    Int?
  maxAffectivePeriod   ResolutionPeriod?

  @@index([userId, monthKey])
  @@index([userId])
}

enum TimerMode {
  SHORT  // 25/5
  LONG   // 50/10
}

enum TimerPhase {
  LEARN
  PAUSE
}

model Timer {
  id                String     @id @default(uuid())
  userId            String     @unique
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  mode              TimerMode
  startTime         DateTime
  currentPhase      TimerPhase
  phaseStartTime    DateTime
  totalElapsedSeconds Int      @default(0)
  learnSeconds      Int        @default(0)
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  @@index([userId])
}
